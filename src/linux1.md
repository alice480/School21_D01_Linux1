## Part 1. Установка ОС

**== Задание ==**

Установить Ubuntu 20.04 Server LTS без графического интерфейса. (Используем программу для виртуализации - VirtualBox)

- Графический интерфейс должен отсутствовать.

- Узнайте версию Ubuntu, выполнив команду 
`cat /etc/issue`.

- Вставьте скриншот с выводом команды.

**== Выполнение ==**

![image info](src/img/part1.png)

## Part 2. Создание пользователя

**== Задание ==**

Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен быть добавлен в группу adm.

Вставьте скриншот вызова команды для создания пользователя.
Новый пользователь должен быть в выводе команды 
cat /etc/passwd

Вставьте скриншот с выводом команды.

**== Выполнение ==**

- Создадим нового пользователя _school21_user_ с помощью команды `sudo adduser school21_user`

![image info](src/img/part2_adduser.png)

- Добавим данного пользователя в группу _adm_: `sudo usermod -a -G adm school21_user`

![image info](src/img/part2_usermod.png)

- Введем команду `cat /etc/passwd`

![image info](src/img/part2_passwd.png)

- Проверим, что информация о пользователе _school21_user_ присутствует в выводе:

![image info](src/img/part2_ect_passwd.png)

## Part 3. Настройка сети ОС

**== Задание ==**

Задать название машины вида user-1

Установить временную зону, соответствующую вашему текущему местоположению.

Вывести названия сетевых интерфейсов с помощью консольной команды.

- В отчёте дать объяснение наличию интерфейса lo.


Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера.

- В отчёте дать расшифровку DHCP.


Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw).

Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8).

Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте.


- В отчёте опишите, что сделали для выполнения всех семи пунктов (можно как текстом, так и скриншотами).
- Успешно пропинговать удаленные хосты 1.1.1.1 и ya.ru и вставить в отчёт скрин с выводом команды. В выводе команды должна быть фраза "0% packet loss".

**== Выполнение ==**


- Введем команду `sudo hostname user-1`, чтобы задать имя хоста, которое сохранится и при перезапуске виртуальной машины
![image info](src/img/part3_hostnamectl.png)

---

- Введем команду sudo timedatectl `set-timezone Europe/Moscow` и проверим, что временная зона была изменена

![image info](src/img/part3_timedatectl.png)

---

- Выведем названия сетевых интерфейсов в компактном виде при помощи `ip -br link show`

![image info](src/img/part3_link_show.png)

При выводе команды видно наличие интерфейса lo

> **lo** (интерфейс loopback) — виртуальный интерфейс, который по умолчанию присутствует в любом Linux. Он используется сетевым клиентским программным обеспечением, чтобы общаться с серверным приложением, расположенным на том же компьютере. Наиболее широко используемый IP адрес в механизмах loopback — 127.0.0.1.
---

- Получим ip-адрес устройства от DHCP-сервера

![image info](src/img/part3_dhcp.png)

Можно сделать вывод, что DHCP-сервер предложил используемому устройству адрес _10.0.2.0/24_, после чего он его использлование было подтверждено, и адрес закрепился за устройством.

> **DHCP** (англ. Dynamic Host Configuration Protocol — протокол динамической настройки узла) — сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. 

---

- Выведем внешний ip-адрес шлюза с помощью команды `curl icanhazip.com`

![image info](src/img/part3_external_ip.png)

- Выведем внутренний ip-адрес шлюза с помощью команд `ip route | grep default` или `hostname -I`

![image info](src/img/part3_default_ip.png)

---

- Зададим статичные настройки ip, gw, dns.

- Для начала необходимо отключить облачную инициализацию. Для этого нужно открыть файл конфигурации _subiquity-disable-cloudinit-networking.cfg_ в каталоге _/etc/cloud/cloud.cfg.d/_ с помощью команды:
`sudo nano /etc/cloud/cloud.cfg.d/subiquity-disable-cloudinit-networking.cfg`

- Проверим, что _network_ в положении _disabled_.

![image info](src/img/part3_network_disabled.png)

- Чтобы назначить статический IP-адрес в сетевом интерфейсе, откройем файл конфигурации YAML в текстовом редакторе:
`sudo nano /etc/netplan/00-installer-config.yaml`

![image info](src/img/part3_config_yaml.png)

- Установим значение _dhcp4_ на _no_, чтобы отключить протокол DHCP, а также вручную зададим настройки _ip_, _gw_, _dns_

![image info](src/img/part3_modified_config.png)

- Для применения внесенных изменений выполняем команду:

![image info](src/img/part3_netplan_apply.png)

- Убедимся,что сетевой интерфейс настрроен на использование статического IP-адреса с помощью `ip route show`

![image info](src/img/part3_ststic_ip.png)

- Перезапустим виртуальную машину и проверим, что файл с настройками не изменился

![image info](src/img/part3_check_saving.png)

---

- Пропингуем удаленные хосты 1.1.1.1 и ya.ru

![image info](src/img/part3_ping.png)

## Part 4

**== Задание ==**

- Обновить системные пакеты до последней на момент выполнения задания версии.

- После обновления системных пакетов, если ввести команду обновления повторно, должно появится сообщение, что обновления отсутствуют.

**== Выполнение ==**

- Для обновления системынх пакетов используем команды _update_ для синхронизации индекса пакетов из репозиториев и _upgrade_  для установки самых новых версий пакетов, установленных в системе

![image info](src/img/part4_update.png)

![image info](src/img/part4_upgrade.png)

- Проверим, что сисетма была обновлена, повторно введя sudo apt-get upgrade и получив сообщение об обновлении 0 пакетов

![image info](src/img/part4_no_updates.png)

## Part 5

**== Задание ==**

Разрешить пользователю, созданному в Part 2, выполнять команду sudo.

- В отчёте объяснить истинное назначение команды sudo.
- Поменять hostname ОС от имени пользователя, созданного в пункте Part 2 (используя sudo).

**== Выполнение ==**

- Добавим пользователя _school21_user_ в группу _sudo_

![image info](src/img/part5_sudo.png)

- Сменим пользователя на schol21_user с помощью команды su, введя пароль, заданный в Part 2 при создании пользователя

![image info](src/img/part5_su.png)

- Поменяем _hostmame_ от лица пользователя _school21_user_

![image info](src/img/part5_hostnamectl.png)

> **sudo** (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы. Основная идея — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач.

## Part 6. Установка и настройка службы времени

**== Задание ==**

- Настроить службу автоматической синхронизации времени.
- Вывести время, часового пояса, в котором вы сейчас находитесь.
- Вывод следующей команды должен содержать NTPSynchronized=yes: 
timedatectl show

**== Выполнение ==**

![image info](src/img/part6.png)

## Part 7. Установка и использование текстовых редакторов

**Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)**

**Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений.**


- В отчёт вставьте скриншоты:
    - Из каждого редактора с содержимым файла перед закрытием.
- В отчёте укажите, что сделали для выхода с сохранением изменений.


**Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений.**

- В отчёт вставьте скриншоты:
    -  Из каждого редактора с содержимым файла после редактирования.
- В отчёте укажите, что сделали для выхода без сохранения изменений.


**Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое.**

- В отчёт вставьте скриншоты:
    - Из каждого редактора с результатами поиска слова.
- Из каждого редактора с командами, введёнными для замены слова на другое.

**== Выполнение ==**

- Установим недостающий редактор _joe_

![image info](src/img/part7_install_joe.png)

---

- Запишем ник с помощью _vim_

![image info](src/img/part7_nick_vim.png)
- Для выхода с сохранением после нажатия _esc_ введем _:x_

---

- Запишем ник с помощью _nano_

![image info](src/img/part7_nick_nano.png)

- Для выхода с сохранением воспользуемся _ctrl+x_ и при возникновении вопроса `Save modified buffer?` выберем _Y_

---

- Запишем ник с помощью _joe_

![image info](src/img/part7_nick_joe.png)

- Для выхода с сохранением воспользуемся _ctrl+k+x_

---

- Проверим, что были созданы файлы, содержащие ник _haricotw_

![image info](src/img/part7_cat_nick.png)

---

- Изменим test_vim.txt

![image info](src/img/part7_vim_school21.png)

- Для выхода без сохранения изменений после нажатия _esc_ введем _:q!_

---

- Изменим test_nano.txt

![image info](src/img/part7_nano_school21.png)

- Для выхода без сохранения изменений после _ctrl+x_ при возникновении `Save modified buffer?` выберем _N_

---

- Изменим test_joe.txt

![image info](src/img/part7_joe_school21.png)

- Для выхода без сохранения изменений после _ctrl+c_ при возникновении `Отменить изменения файла?` выберем _y_

---

- Отредактируем _test_vim.txt_ еще раз, сохранив изменения. После найдем слово _School_

![image info](src/img/part7_find_vim.png)

- Заменим _Sch_ на _P_

![image info](src/img/part7_replace_vim.png)

- Выйдем, сохранив изменения

---

- Отредактируем _test_nano.txt_ и сохраним изменения. Найдем _oo_. Для этого воспользуемся _ctrl+W_, введем слово, нажмем _enter_

![image info](src/img/part7_find_nano.png)

![image info](src/img/part7_find_res_nano.png.png)

- В результате сообщается о количестве совпадений, а курсор перемещается на начало найденной строки

- Заменим _ool_ на _edule_. Для этого воспользуемся _ctrl+\_, введем заменяемое слово, нажмем enter

![image info](src/img/part7_serch_to_replace_nano.png)

- Вводим слово для замены, нажимаем _enter_

![image info](src/img/part7_replace.png)

- Подтверждаем замену, выбрав _Y_

![image info](src/img/part7_replace_confirm_nano.png)

- В резултате получаем новое слово, выходим с сохранением

![image info](src/img/part7_replace_res_nano.png)

---

- Отредактируем _test_joe.txt_ и сохраним изменения. Найдем _School_. Для этого воспользуемя сочетанием _ctrl+K+F_

![image info](src/img/part7_find_joe.png)

- Поскольку поиск осуществляется с начала блока (файла), нажмем _enter_

![image info](src/img/part7_find2_joe.png)

- В результате курсор устанавливается на начало найденного слова

![image info](src/img/part7_find_res_joe.png)

- Заменим все вхождения _21_ на _42_. Для этого воспользуемся _ctrl+K+F_, введем Заменяемое слово, нажмем _enter_

![image info](src/img/part7_search_to_replace_joe.png)

- Вводим _R_ для выбора операции замены, вводим слово для замены, нажимаем _enter_

![image info](src/img/part7_replace_joe.png)

- Выбираем вариант заменить все с помощью _R_

![image info](src/img/part7_replace2_joe.png)

- В резултате получаем две замены, выходим с сохранением

![image info](src/img/part7_replase_res_joe.png)

---

Проверим, что все изменения были сохранены

![image info](src/img/part7_replaces_results.png)


## Part 8. Установка и базовая настройка сервиса SSHD

**== Задание ==**

**Установить службу SSHd.**

**Добавить автостарт службы при загрузке системы.**

**Перенастроить службу SSHd на порт 2022.**

**Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи.**


- В отчёте объяснить значение команды и каждого ключа в ней.


**Перезагрузить систему.**

- В отчёте опишите, что сделали для выполнения всех пяти пунктов (можно как текстом, так и скриншотами).
- Вывод команды netstat -tan должен содержать `tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN` (если команды netstat нет, то ее нужно установить)
- Скрин с выводом команды вставить в отчёт.
- В отчёте объяснить значение ключей -tan, значение каждого столбца вывода, значение 0.0.0.0.

**== Выполнение ==**

- Установим _SSH_:

![image info](src/img/part8_install_ssh.png)
![image info](src/img/part8_install2_ssh.png)

- Установим _openssh_ (в данном случае сообщается о том, что _openssh_ уже установлен)

![image info](src/img/part8_install_openssh.png)

- Проверяем, что автостарт службы при загрузке системы был добавлен. На это указывает _enabled_ в _Loaded_

![image info](src/img/part8_sshd_status.png)

- Установим netstat, чтобы узнать, какие порты уже задействованы и не испольовать их повторно

![image info](src/img/part8_sshd_status.png)

- Выполним _sudo nano /etc/ssh/sshd_config_

![image info](src/img/part8_config.png)

- Поменяем _Port_ на _2022_ и выйдем, сохранив изменения. 

![image info](src/img/part8_config2022.png)

- Перезапустим службу SSH, чтобы изменения вступили в силу: `sudo systemctl restart ssh`

- Проверим, запущен ли ssh-демон на вашем сервере с помощью команды ps

![image info](src/img/part8_ps.png)

> Команда **_ps_**, сокращенно от _Process Status_, представляет собой утилиту командной строки, которая используется для отображения или просмотра информации, связанной с процессами, запущенными в системе Linux.

> **_a_** отображает идентификаторы процессов и состояние идентификатора сеанса для каждого реального пользователя.

> **_u_** — это ширина экрана по умолчанию и формат виртуальной памяти с более ценными функциями, а также общая пользовательская настройка управления форматом вывода.

> **_x_** предоставляет следующие столбцы: PID, TTY, STAT, TIME, COMMAND. Вывод «x» аналогичен выводу «u», но разница в том, что «x» отображает процессы, которые выполняются без привязки к какому-либо экрану терминала.

> **_grep sshd_** выводит строки, содержащие _sshd_

- Выполним _reboot_ и _netstat -tan_

![image info](src/img/part8_netstat.png)

> **_a_** выводит список всех портов и соединений независимо от их состояния или протокола

> **_t_** выводит порты tcp

> **_n_** показывает числовые адреса

> **_tan_** выведет список всех портов TCP с с отображением адресов и номеров портов

- **Значения столблов:**

> **_Proto_** — Протокол (tcp, udp, raw), используемый сокетом.

> **_Reqv-Q_** — Счётчик байт не скопированных программой пользователя из этого сокета.

> **_Send-Q_** — Счётчик байтов, не подтверждённых удалённым узлом.

> **_Local Address_** — Адрес и номер порта локального конца сокета.

> **_Foreign Address_** — Адрес и номер порта удалённого конца сокета. 

> **_State_** — Состояние сокета. **_LISTEN_** — Сокет ожидает входящих подключений.

- **Значение 0.0.0.0.**

> **_IP-адрес 0.0.0.0_** — это немаршрутизируемый адрес IPv4, который можно использовать в разных целях, в основном, в качестве адреса по умолчанию или адреса-заполнителя. Он действует как резервный, пока не будет назначен действительный маршрутизируемый IP-адрес.


## Part 9. Установка и использование утилит top, htop

**== Задание ==**

**Установить и запустить утилиты top и htop.**

- По выводу команды top определить и написать в отчёте:
    - uptime
    - количество авторизованных пользователей
    - общую загрузку системы
    - общее количество процессов
    - загрузку cpu
    - загрузку памяти
    - pid процесса занимающего больше всего памяти
    - pid процесса, занимающего больше всего процессорного времени
- В отчёт вставить скрин с выводом команды htop:
    - отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME
    - отфильтрованному для процесса sshd
    - с процессом syslog, найденным, используя поиск
    - с добавленным выводом hostname, clock и uptime

**== Выполнение ==**

- Установим _htop_ `sudo apt install htop`
- Выполним top

![image info](src/img/part9_top.png)

    - uptime: 16 минут
    - количество авторизованных пользователей: 1
    - общую загрузку системы: 0,00
    - общее количество процессов: 96
    - загрузку cpu: 0.0%
    - загрузку памяти: 148.1 из 3932.0
    - pid процесса занимающего больше всего памяти: 1
    - pid процесса, занимающего больше всего процессорного времени: 1273

- _htop_, отсортированный по _PID_

![image info](src/img/part9_htop_pid.png)

- _htop_, отсортированный по _PERCENT_CPU_

![image info](src/img/part9_htop_cpu.png)

- _htop_, отсортированный по _PERCENT_MEM_

![image info](src/img/part9_htop_mem.png)

- _htop_, отсортированный по _TIME_

![image info](src/img/part9_htop_time.png)

- _htop_, отфильтрованный для процесса _sshd_

![image info](src/img/part9_htop_sshd.png)

- _htop_, с найденным с помощбю поиска процессом syslog

![image info](src/img/part9_syslog.png)

- Добавленный вывод hostname, clock и uptime

![image info](src/img/part9_htop_adding.png)


## Part 10. Использование утилиты fdisk

**== Задание ==**

**Запустить команду fdisk -l.**

- В отчёте написать название жесткого диска, его размер и количество секторов, а также размер swap.

**== Выполнение ==**

![image info](src/img/part10_fdisk.png)

- Название: VBOX HARDDISK
- Размер: 20 Гб
- Количество секторов: 41943040
- Размер swap: 0 байт

![image info](src/img/part10_swap.png)

## Part 11. Part 11. Использование утилиты df

**== Задание ==**

**Запустить команду df.**

- В отчёте написать для корневого раздела (/):
    - размер раздела
    - размер занятого пространства
    - размер свободного пространства
    - процент использования

- Определить и написать в отчёт единицу измерения в выводе.

**Запустить команду df -Th.**

- В отчёте написать для корневого раздела (/):
    - размер раздела
    - размер занятого пространства
    - размер свободного пространства
    - процент использования

- Определить и написать в отчёт тип файловой системы для раздела.

**== Выполнение ==**

- Выполним `df`

![image info](src/img/part11_df.png)

    - размер раздела: 10218772 Кб
    - размер занятого пространства: 3291064 Кб
    - размер свободного пространства: 6387036 Кб
    - процент использования: 35%

- Единица измерения: Кб (по умолчанию количество места на дисках выводится в килобайтах, если не указан какой-либо ключ)

- Выполним `df -Th`

![image info](src/img/part11_df_th.png)

    - размер раздела: 9.8 Гб
    - размер занятого пространства: 3.2 Гб
    - размер свободного пространства: 6.1 Гб
    - процент использования: 35%
- Тип файловой системы для раздела: ext4 ((англ. fourth extended file system, ext4fs) — журналируемая файловая система)


## Part 12. Использование утилиты du

**== Задание ==**

**Запустить команду du.**

**Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)**

**Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента)**


**== Выполнение ==**

- Выполним `du`

![image info](src/img/part12_du.png)

- Выведем размер папок _/home_, _/var_, _/var/log_ в человекочитаемом виде в байтах 

![image info](src/img/part12_du_home_var_log.png)

- Выведем размер каждого вложенного элемента в _/var/log_

![image info](src/img/part12_varlog.png)


## Part 13. Установка и использование утилиты ncdu

**== Задание ==**

**Установить утилиту ncdu.**

**Вывести размер папок /home, /var, /var/log.**

- Размеры должны примерно совпадать с полученными в Part 12.


**== Выполнение ==**

- Установим _ncdu_

![image info](src/img/part13_install.png)

- Выведем размер папки _/home_

![image info](src/img/part13_ncdu_home.png)

- Выведем размер папки _/var_

![image info](src/img/part13_ncdu_var.png)

- Выведем размер папки _/var/log_

![image info](src/img/part13_ncdu_varlog.png)


## Part 14. Работа с системными журналами

**== Задание ==**

**Открыть для просмотра:**

1. /var/log/dmesg

2. /var/log/syslog

3. /var/log/auth.log

- Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему.
- Перезапустить службу SSHd.
- Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах).

**== Выполнение ==**

- Откроем для просмотра _/var/log/dmesg_

![image info](src/img/part14_dmesg.png)

- Откроем для просмотра _/var/log/syslog_

![image info](src/img/part14_syslog.png)

- Откроем для просмотра _/var/log/auth.log_ 

![image info](src/img/part14_authlog.png)

- Время последней успешной авторизации: _21:36:32_
- Имя пользователя: _haricotw_
- Метод входа в систему: by uid = 0 (User Identifier). Суперпользователь всегда должен иметь UID, равный нулю.

- Перезапустим службу SSHd: `systemctl restart ssh`

![image info](src/img/part14_restart_sshd.png)

- Найдем в _/var/log/auth.log_ сообщение о рестарте службы _sshd_

![image info](src/img/part14_log.png)


## Part 15. Использование планировщика заданий CRON

**== Задание ==**

**Используя планировщик заданий, запустите команду uptime через каждые 2 минуты.**

- Найти в системных журналах строчки (минимум две в заданном временном диапазоне) о выполнении.
- Вывести на экран список текущих заданий для CRON.
- Вставить в отчёт скрины со строчками о выполнении и списком текущих задач.

**Удалите все задания из планировщика заданий.**

- В отчёт вставьте скрин со списком текущих заданий для CRON.

**== Выполнение ==**

- Создадим файл расписания для текущего пользователя: `crontab -e`

![image info](src/img/part15_cron.png)

- Просмотрим список текущих заданий для CRON

![image info](src/img/part15_ctron_l.png)

- Найдем в системном журнале строчки о выполнении _uptime_

![image info](src/img/part15_uptime.png)

- Удалим все задания из планировщика и проверим, что список заданий пуст 

![image info](src/img/part15_delete.png)





